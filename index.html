<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>LD46</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.19.0/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>
<script type="text/javascript">
var config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 0 },
            debug: false
        }
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    },
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
    }
}

var player;
var player_projectiles;
var health_bar;
var cpu_health_bar
var cpu;
var enemies;
var particulates;
var cursors;
var firing = false;
var lock_position = false;
var lock_key = false;
var graphics;
var invincible;
var enemy_slows = true;
var walls;
var debug_text
var player_bounced

var game = new Phaser.Game(config);

function preload() {
    load_cpu(this);
    load_player(this);
    load_enemies(this);
    loadLeftConfluence(this)
    graphics = this.add.graphics();
}

function create() {
    cursors = this.input.keyboard.createCursorKeys();

    create_cpu(this);
    create_player(this);
    create_enemies(this);
    createLeftConfluence(this);
    this.cameras.main.startFollow(player);
    this.input.keyboard.on('keydown-F', function(e) {
        if(this.scale.isFullscreen) {
            this.scale.stopFullscreen();
        } else {
            this.scale.startFullscreen();
        }
    }, this);

    var canvascenterX = this.sys.game.canvas.width * 0.5 - 180;
    var canvascenterY = this.sys.game.canvas.height * 0.5 - 50;
    game_over_text = this.add.text(canvascenterX, canvascenterY, '', {fontSize: '64px', fill: 'red'});
    game_over_text.setScrollFactor(0);

    debug_text = this.add.text(100, 100, '', {fontSize: '64px', fill: 'white'});
    debug_text.setScrollFactor(0);

    this.children.bringToTop(graphics);
    this.children.bringToTop(player.health_display);
    this.children.bringToTop(cpu.health_display);
}

function update() {
    update_cpu(this);
    update_player(this);
    debug_text.setText(Phaser.Math.FloorTo(player.x/32) + ',' + Phaser.Math.FloorTo(player.y/32))
    if(Phaser.Math.Between(0, 100) % 99 == 0) {
        update_enemies(this);
    }

    if(player.health <= 0 || cpu.health <= 0) {
        game_over_text.setText('GAME OVER');
        enemies.children.iterate(function(child) {
            child.disableBody(true, true);
        });
        particulates.children.iterate(function(child) {
            child.disableBody(true, true);
        });
        player.disableBody(true, true);
        return;
    }
}


//////////////////////////////////////////PLAYER///////////////////////////////////////
function load_player(game) {
    game.load.spritesheet('psu', 'assets/power_supply_unit_ld46.png', { frameWidth: 32, frameHeight: 32 });
    game.load.spritesheet('low', 'assets/low_volt.png', { frameWidth: 16, frameHeight: 16 });
    game.load.image('psu-health', 'assets/psu_health.png');
}

function create_player(game) {
    player = game.physics.add.sprite(100, 100, 'psu');
    player.health_display = game.add.image(0, 0, 'psu-health');
    player.health_display.setScrollFactor(0);
    player.health_display.setOrigin(0, 0);
    //player.setCollideWorldBounds(true);
    player_projectiles = game.physics.add.group();
    player.speed = 200;
    player.firingSpeed = 500;
    player.health = 100;
    health_bar = game.add.rectangle(5, 4, ((player.health_display.width - 10) / 100) * player.health, player.health_display.height-5);
    graphics.setScrollFactor(0, 0);
    graphics.fillStyle(0xee6b3b);
    graphics.fillRectShape(health_bar);
    game.physics.add.collider(player, cpu);
    game.physics.add.overlap(cpu, player_projectiles, function(cpu, projectile) {
        projectile.disableBody(true, true);
    }, null, this);
    

    game.anims.create({
       key:'left',
       frames: [{key: 'psu', frame: 3}],
       repeat: -1
    });

    game.anims.create({
       key:'right',
       frames: [{key: 'psu', frame: 2}],
       repeat: -1
    });

    game.anims.create({
       key:'up',
       frames: [{key: 'psu', frame: 0}],
       repeat: -1
    });

    game.anims.create({
       key:'down',
       frames: [{key: 'psu', frame: 1}],
       repeat: -1
    });

    game.anims.create({
       key:'up-left',
       frames: [{key: 'psu', frame: 3}],
       repeat: -1
    });

    game.anims.create({
       key:'up-right',
       frames: [{key: 'psu', frame: 2}],
       repeat: -1
    });

    game.anims.create({
       key:'down-left',
       frames: [{key: 'psu', frame: 3}],
       repeat: -1
    });

    game.anims.create({
       key:'down-right',
       frames: [{key: 'psu', frame: 2}],
       repeat: -1
    });
}

function update_player() {
    

    if(lock_key.isDown) {
        lock_position = true;
    } else {
        lock_position = false;
    }

    if(!player_bounced) {
        if(cursors.right.isDown) {
                if(cursors.up.isDown) {
                    player.setVelocityX(player.speed);
                    player.setVelocityY(-player.speed);
                    if(!lock_position) {
                        player.anims.play('up-right')
                    }
                } else if(cursors.down.isDown) {
                    player.setVelocityX(player.speed);
                    player.setVelocityY(player.speed);
                    if(!lock_position) {
                        player.anims.play('down-right')
                    }
                } else {
                    player.setVelocityX(player.speed);
                    player.setVelocityY(0);
                    if(!lock_position) {
                        player.anims.play('right');
                    }
                }
            } else if(cursors.left.isDown) {
                if(cursors.up.isDown) {
                    player.setVelocityX(-player.speed);
                    player.setVelocityY(-player.speed);
                    if(!lock_position) {
                        player.anims.play('up-left')
                    }
                } else if(cursors.down.isDown) {
                    player.setVelocityX(-player.speed);
                    player.setVelocityY(player.speed);
                    if(!lock_position) {
                        player.anims.play('down-left');
                    }
                } else {
                    player.setVelocityX(-player.speed);
                    player.setVelocityY(0);
                    if(!lock_position) {
                        player.anims.play('left');
                    }
                }
            } else if(cursors.up.isDown) {
                player.setVelocityY(-player.speed);
                player.setVelocityX(0);
                if(!lock_position) {
                    player.anims.play('up');
                }
            } else if(cursors.down.isDown) {
                player.setVelocityY(player.speed);
                player.setVelocityX(0);
                if(!lock_position) {
                    player.anims.play('down');
                }
            } else {
                player.setVelocityX(0);
                player.setVelocityY(0);
            }
        }

    if(cursors.space.isDown) {
        if(!firing) {
            firing = true;
            var projectile = player_projectiles.create(player.x, player.y, 'low');
            var curr_dir = player.anims.currentAnim.key;
            var v = player.firingSpeed;

            switch(curr_dir) {
                case 'up':
                    projectile.setVelocityY(-v);
                break;
                case 'down':
                    projectile.setVelocityY(v);
                break;
                case 'left':
                    projectile.setVelocityX(-v);
                break;
                case 'right':
                    projectile.setVelocityX(v);
                break;
                case 'up-left':
                    projectile.setVelocityY(-v*.75);
                    projectile.setVelocityX(-v*.75);
                break;
                case 'up-right':
                    projectile.setVelocityY(-v*.75);
                    projectile.setVelocityX(v*.75);
                break;
                case 'down-left':
                    projectile.setVelocityX(-v*.75);
                    projectile.setVelocityY(v*.75);
                break;
                case 'down-right':
                    projectile.setVelocityX(v*.75);
                    projectile.setVelocityY(v*.75);
                break;
            }
        }
    } else {
        firing = false;
    }
}



/////////////////////////////////////////CPU///////////////////////////////////////////
function load_cpu(game) {
    game.load.spritesheet('cpu', 'assets/CPULD46.png', { frameWidth: 224, frameHeight: 224 });
    game.load.image('cpu-health', 'assets/CPULD46_Health');
}

function create_cpu(game) {
    var cpus = game.physics.add.staticGroup();
    cpu = cpus.create(300, 300, 'cpu');
    cpu.health = 10000;
    cpu.health_display = game.add.image(0, 30, 'cpu-health');
    cpu.health_display.setScrollFactor(0);
    cpu.health_display.setOrigin(0, 0);
    cpu_health_bar = game.add.rectangle(5, 34, ((cpu.health_display.width - 10) / 10000) * cpu.health, cpu.health_display.height-5);
    graphics.fillStyle(0x262949);
    graphics.fillRectShape(cpu_health_bar);
}

function update_cpu(game) {
}


/////////////////////////////////////////ENEMIES///////////////////////////////////////////
function load_enemies(game) {
    game.load.spritesheet('aq', 'assets/Aq.png', { frameWidth: 32, frameHeight: 32 });
    game.load.spritesheet('particulate', 'assets/particulate.png', { frameWidth: 16, frameHeight: 16 });
}

function create_enemies(game) {

    enemies = game.physics.add.group();
    game.physics.add.overlap(enemies, player_projectiles, function(enemy, projectile) {
        enemy.disableBody(true, true);
        projectile.disableBody(true, true);
    }, null, game);

    game.physics.add.collider(enemies, cpu);

    particulates = game.physics.add.group();

    game.physics.add.overlap(cpu, particulates, function(hit, part) {
        enemyFire(part.parent);
        part.disableBody(true, true);
        cpu.health = cpu.health - 10;
        refreshGraphics(game);
    }, null, this);

    game.physics.add.overlap(player, particulates, function(hit, part) {
        enemyFire(part.parent);
        part.disableBody(true, true);

        player.health = player.health - 10;
        refreshGraphics(game);
    }, null, this);

    game.physics.add.collider(player, enemies, function(p, e) {
        
        var timerForStop = game.time.delayedCall(500, function() {
            setEnemyPath(e, 10);
        });
        if(!invincible) {
            player.health = player.health - 10;
            invincible = true
        }
        var time = game.time.delayedCall(5000, function() {
            invincible = false;
        });
        refreshGraphics(game);
    }, null, this);

}

function update_enemies(game) {
    var ev = 10;//enemy velocity
    //spawn enemy within a 300 range of the player
    var ex = Phaser.Math.Between(player.x - 300, player.x + 300);
    var ey = Phaser.Math.Between(player.y - 300, player.y + 300);

    if(ex > cpu.x-125 && ex < cpu.x+125
    && ey > cpu.y-125 && ey < cpu.y+125) {
        console.log("spawn location in bounds");
    } else {
        var evx = ev;//calculated x velocity
        var evy = ev;//calculated y velocity

        var enemy = enemies.create(ex, ey, 'aq');
        setEnemyPath(enemy, ev);
        enemyFire(enemy)
    }

}

function enemyFire(enemy) {
    var p = particulates.create(enemy.x, enemy.y, 'particulate');
    p.parent = enemy;
    p.setVelocityX(enemy.body.velocity.x*2);
    p.setVelocityY(enemy.body.velocity.y*2);
}

function refreshGraphics(game) {
    graphics.clear();
        health_bar = game.add.rectangle(5, 4, ((player.health_display.width - 10) / 100) * player.health, player.health_display.height-5);
        graphics.setScrollFactor(0, 0);
        graphics.fillStyle(0xee6b3b);
        graphics.fillRectShape(health_bar);

        cpu_health_bar = game.add.rectangle(5, 34, ((cpu.health_display.width - 10) / 10000) * cpu.health, cpu.health_display.height-5);
        graphics.fillStyle(0x262949);
        graphics.fillRectShape(cpu_health_bar);
}

function setEnemyPath(enemy, ev) {
    if(enemy.x > 300) {
            evx = -ev;
        } else {
            evx = ev;
        }

        if(enemy.y > 300) {
            evy = -ev;
        } else {
            evy = ev;
        }

        enemy.setVelocityX(evx);
        enemy.setVelocityY(evy);
}

function enemyContinuousFire(enemy, particulate) {
    if(enemy) {
        var p = particulates.create(enemy.x, enemy.y, 'particulate');
        p.setVelocityX(enemy.body.velocity.x*2);
        p.setVelocityY(enemy.body.velocity.y*2);
    }
}

function loadLeftConfluence(game) {
    game.load.image('wall_01', 'assets/wall_01.png');
    game.load.image('wall_02', 'assets/wall_02.png');
}

function createLeftConfluence(game) {
    walls = game.physics.add.staticGroup();

    walls.create(tile(-5), tile(3), 'wall_01');
    walls.create(tile(-10), tile(3), 'wall_01');
    walls.create(tile(-15), tile(3), 'wall_01');
    walls.create(tile(-20), tile(3), 'wall_01');

    walls.create(tile(-5), tile(13), 'wall_01');
    walls.create(tile(-10), tile(13), 'wall_01');
    walls.create(tile(-15), tile(13), 'wall_01');
    walls.create(tile(-20), tile(13), 'wall_01');

    walls.create(tile(-15), tile(8), 'wall_02');



    game.physics.add.collider(player, walls, function(p , w) {
        player.health -= 5;
        refreshGraphics(game);
        player_bounced = true;
        var timer = game.time.delayedCall(200, function() {
            player_bounced = false;
        });
    });
    player.setBounce(1);
    
}

function tile(dist) {
    return dist*32;
}


</script>
</body>
</html>